# This file is used to manually specify the semi-automatic conversion of
# 'nipype.interfaces.fsl.preprocess.FNIRT' from Nipype to Pydra.
#
# Please fill-in/edit the fields below where appropriate
#
# Docs
# ----
# FSL FNIRT wrapper for non-linear registration
# 
#     For complete details, see the `FNIRT Documentation.
#     <https://fsl.fmrib.ox.ac.uk/fsl/fslwiki/FNIRT>`_
# 
#     Examples
#     --------
#     >>> from nipype.interfaces import fsl
#     >>> from nipype.testing import example_data
#     >>> fnt = fsl.FNIRT(affine_file=example_data('trans.mat'))
#     >>> res = fnt.run(ref_file=example_data('mni.nii', in_file=example_data('structural.nii')) #doctest: +SKIP
# 
#     T1 -> Mni153
# 
#     >>> from nipype.interfaces import fsl
#     >>> fnirt_mprage = fsl.FNIRT()
#     >>> fnirt_mprage.inputs.in_fwhm = [8, 4, 2, 2]
#     >>> fnirt_mprage.inputs.subsampling_scheme = [4, 2, 1, 1]
# 
#     Specify the resolution of the warps
# 
#     >>> fnirt_mprage.inputs.warp_resolution = (6, 6, 6)
#     >>> res = fnirt_mprage.run(in_file='structural.nii', ref_file='mni.nii', warped_file='warped.nii', fieldcoeff_file='fieldcoeff.nii')#doctest: +SKIP
# 
#     We can check the command line and confirm that it's what we expect.
# 
#     >>> fnirt_mprage.cmdline  #doctest: +SKIP
#     'fnirt --cout=fieldcoeff.nii --in=structural.nii --infwhm=8,4,2,2 --ref=mni.nii --subsamp=4,2,1,1 --warpres=6,6,6 --iout=warped.nii'
# 
#     
task_name: FNIRT
nipype_name: FNIRT
nipype_module: nipype.interfaces.fsl.preprocess
inputs:
  omit:
  # list[str] - fields to omit from the Pydra interface
  rename:
  # dict[str, str] - fields to rename in the Pydra interface
  types:
  # dict[str, type] - override inferred types (use "mime-like" string for file-format types,
  # e.g. 'medimage/nifti-gz'). For most fields the type will be correctly inferred
  # from the nipype interface, but you may want to be more specific, particularly
  # for file types, where specifying the format also specifies the file that will be
  # passed to the field in the automatically generated unittests.
    ref_file: generic/file
    # type=file|default=<undefined>: name of reference image
    in_file: generic/file
    # type=file|default=<undefined>: name of input image
    affine_file: generic/file
    # type=file|default=<undefined>: name of file containing affine transform
    inwarp_file: generic/file
    # type=file|default=<undefined>: name of file containing initial non-linear warps
    in_intensitymap_file: generic/file+list-of
    # type=list|default=[]: name of file/files containing initial intensity mapping usually generated by previous fnirt run
    refmask_file: generic/file
    # type=file|default=<undefined>: name of file with mask in reference space
    inmask_file: generic/file
    # type=file|default=<undefined>: name of file with mask in input image space
  metadata:
  # dict[str, dict[str, any]] - additional metadata to set on any of the input fields (e.g. out_file: position: 1)
outputs:
  omit:
  # list[str] - fields to omit from the Pydra interface
  rename:
  # dict[str, str] - fields to rename in the Pydra interface
  types:
  # dict[str, type] - override inferred types (use "mime-like" string for file-format types,
  # e.g. 'medimage/nifti-gz'). For most fields the type will be correctly inferred
  # from the nipype interface, but you may want to be more specific, particularly
  # for file types, where specifying the format also specifies the file that will be
  # passed to the field in the automatically generated unittests.
    fieldcoeff_file: generic/file
    # type=file: file with field coefficients
    # type=traitcompound|default=None: name of output file with field coefficients or true
    warped_file: generic/file
    # type=file: warped image
    # type=file|default=<undefined>: name of output image
    field_file: generic/file
    # type=file: file with warp field
    # type=traitcompound|default=None: name of output file with field or true
    jacobian_file: generic/file
    # type=file: file containing Jacobian of the field
    # type=traitcompound|default=None: name of file for writing out the Jacobian of the field (for diagnostic or VBM purposes)
    modulatedref_file: generic/file
    # type=file: file containing intensity modulated --ref
    # type=traitcompound|default=None: name of file for writing out intensity modulated --ref (for diagnostic purposes)
    log_file: generic/file
    # type=file: Name of log-file
    # type=file|default=<undefined>: Name of log-file
  callables:
  # dict[str, str] - names of methods/callable classes defined in the adjacent `*_callables.py`
  # to set to the `callable` attribute of output fields
  templates:
  # dict[str, str] - `output_file_template` values to be provided to output fields
    warped_file: warped_file
    # type=file: warped image
    # type=file|default=<undefined>: name of output image
    log_file: log_file
    # type=file: Name of log-file
    # type=file|default=<undefined>: Name of log-file
  requirements:
  # dict[str, list[str]] - input fields that are required to be provided for the output field to be present
tests:
- inputs:
  # dict[str, str] - values to provide to inputs fields in the task initialisation
  # (if not specified, will try to choose a sensible value)
    ref_file:
    # type=file|default=<undefined>: name of reference image
    in_file:
    # type=file|default=<undefined>: name of input image
    affine_file:
    # type=file|default=<undefined>: name of file containing affine transform
    inwarp_file:
    # type=file|default=<undefined>: name of file containing initial non-linear warps
    in_intensitymap_file:
    # type=list|default=[]: name of file/files containing initial intensity mapping usually generated by previous fnirt run
    fieldcoeff_file:
    # type=file: file with field coefficients
    # type=traitcompound|default=None: name of output file with field coefficients or true
    warped_file:
    # type=file: warped image
    # type=file|default=<undefined>: name of output image
    field_file:
    # type=file: file with warp field
    # type=traitcompound|default=None: name of output file with field or true
    jacobian_file:
    # type=file: file containing Jacobian of the field
    # type=traitcompound|default=None: name of file for writing out the Jacobian of the field (for diagnostic or VBM purposes)
    modulatedref_file:
    # type=file: file containing intensity modulated --ref
    # type=traitcompound|default=None: name of file for writing out intensity modulated --ref (for diagnostic purposes)
    out_intensitymap_file:
    # type=list: files containing info pertaining to intensity mapping
    # type=traitcompound|default=None: name of files for writing information pertaining to intensity mapping
    log_file:
    # type=file: Name of log-file
    # type=file|default=<undefined>: Name of log-file
    config_file:
    # type=traitcompound|default=None: Name of config file specifying command line arguments
    refmask_file:
    # type=file|default=<undefined>: name of file with mask in reference space
    inmask_file:
    # type=file|default=<undefined>: name of file with mask in input image space
    skip_refmask:
    # type=bool|default=False: Skip specified refmask if set, default false
    skip_inmask:
    # type=bool|default=False: skip specified inmask if set, default false
    apply_refmask:
    # type=list|default=[]: list of iterations to use reference mask on (1 to use, 0 to skip)
    apply_inmask:
    # type=list|default=[]: list of iterations to use input mask on (1 to use, 0 to skip)
    skip_implicit_ref_masking:
    # type=bool|default=False: skip implicit masking  based on value in --ref image. Default = 0
    skip_implicit_in_masking:
    # type=bool|default=False: skip implicit masking  based on value in --in image. Default = 0
    refmask_val:
    # type=float|default=0.0: Value to mask out in --ref image. Default =0.0
    inmask_val:
    # type=float|default=0.0: Value to mask out in --in image. Default =0.0
    max_nonlin_iter:
    # type=list|default=[]: Max # of non-linear iterations list, default [5, 5, 5, 5]
    subsampling_scheme:
    # type=list|default=[]: sub-sampling scheme, list, default [4, 2, 1, 1]
    warp_resolution:
    # type=tuple|default=(0, 0, 0): (approximate) resolution (in mm) of warp basis in x-, y- and z-direction, default 10, 10, 10
    spline_order:
    # type=int|default=0: Order of spline, 2->Qadratic spline, 3->Cubic spline. Default=3
    in_fwhm:
    # type=list|default=[]: FWHM (in mm) of gaussian smoothing kernel for input volume, default [6, 4, 2, 2]
    ref_fwhm:
    # type=list|default=[]: FWHM (in mm) of gaussian smoothing kernel for ref volume, default [4, 2, 0, 0]
    regularization_model:
    # type=enum|default='membrane_energy'|allowed['bending_energy','membrane_energy']: Model for regularisation of warp-field [membrane_energy bending_energy], default bending_energy
    regularization_lambda:
    # type=list|default=[]: Weight of regularisation, default depending on --ssqlambda and --regmod switches. See user documentation.
    skip_lambda_ssq:
    # type=bool|default=False: If true, lambda is not weighted by current ssq, default false
    jacobian_range:
    # type=tuple|default=(0.0, 0.0): Allowed range of Jacobian determinants, default 0.01, 100.0
    derive_from_ref:
    # type=bool|default=False: If true, ref image is used to calculate derivatives. Default false
    intensity_mapping_model:
    # type=enum|default='none'|allowed['global_linear','global_non_linear','global_non_linear_with_bias','local_linear','local_non_linear','none']: Model for intensity-mapping
    intensity_mapping_order:
    # type=int|default=0: Order of poynomial for mapping intensities, default 5
    biasfield_resolution:
    # type=tuple|default=(0, 0, 0): Resolution (in mm) of bias-field modelling local intensities, default 50, 50, 50
    bias_regularization_lambda:
    # type=float|default=0.0: Weight of regularisation for bias-field, default 10000
    skip_intensity_mapping:
    # type=bool|default=False: Skip estimate intensity-mapping default false
    apply_intensity_mapping:
    # type=list|default=[]: List of subsampling levels to apply intensity mapping for (0 to skip, 1 to apply)
    hessian_precision:
    # type=enum|default='double'|allowed['double','float']: Precision for representing Hessian, double or float. Default double
    output_type:
    # type=enum|default='NIFTI'|allowed['NIFTI','NIFTI_GZ','NIFTI_PAIR','NIFTI_PAIR_GZ']: FSL output type
    args:
    # type=str|default='': Additional parameters to the command
    environ:
    # type=dict|default={}: Environment variables
  imports:
  # list[nipype2pydra.task.importstatement] - list import statements required by the test, with each list item
  # consisting of 'module', 'name', and optionally 'alias' keys
  expected_outputs:
  # dict[str, str] - expected values for selected outputs, noting that tests will typically
  # be terminated before they complete for time-saving reasons, and therefore
  # these values will be ignored, when running in CI
  timeout: 10
  # int - the value to set for the timeout in the generated test, 
  # after which the test will be considered to have been initialised 
  # successfully. Set to 0 to disable the timeout (warning, this could
  # lead to the unittests taking a very long time to complete)
  xfail: true
  # bool - whether the unittest is expected to fail or not. Set to false
  # when you are satisfied with the edits you have made to this file
- inputs:
  # dict[str, str] - values to provide to inputs fields in the task initialisation
  # (if not specified, will try to choose a sensible value)
    in_fwhm: '[8, 4, 2, 2]'
    # type=list|default=[]: FWHM (in mm) of gaussian smoothing kernel for input volume, default [6, 4, 2, 2]
    subsampling_scheme: '[4, 2, 1, 1]'
    warp_resolution: '(6, 6, 6)'
    # type=list|default=[]: sub-sampling scheme, list, default [4, 2, 1, 1]
  imports: &id001
  # list[nipype2pydra.task.importstatement] - list import statements required by the test, with each list item
  # consisting of 'module', 'name', and optionally 'alias' keys
  - module: nipype.testing
    name: example_data
    alias:
  expected_outputs:
  # dict[str, str] - expected values for selected outputs, noting that tests will typically
  # be terminated before they complete for time-saving reasons, and therefore
  # these values will be ignored, when running in CI
  timeout: 10
  # int - the value to set for the timeout in the generated test, 
  # after which the test will be considered to have been initialised 
  # successfully. Set to 0 to disable the timeout (warning, this could
  # lead to the unittests taking a very long time to complete)
  xfail: true
  # bool - whether the unittest is expected to fail or not. Set to false
  # when you are satisfied with the edits you have made to this file
doctests:
- cmdline:
  # str - the expected cmdline output
  inputs:
  # dict[str, str] - name-value pairs for inputs to be provided to the doctest.
  # If the field is of file-format type and the value is None, then the
  # '.mock()' method of the corresponding class is used instead.
    in_fwhm: '[8, 4, 2, 2]'
    # type=list|default=[]: FWHM (in mm) of gaussian smoothing kernel for input volume, default [6, 4, 2, 2]
    subsampling_scheme: '[4, 2, 1, 1]    Specify the resolution of the warps    >>> fnirt_mprage.inputs.warp_resolution = (6, 6, 6)'
    # type=list|default=[]: sub-sampling scheme, list, default [4, 2, 1, 1]
  imports: *id001
  # list[nipype2pydra.task.importstatement] - list import statements required by the test, with each list item
  # consisting of 'module', 'name', and optionally 'alias' keys
  directive:
  # str - any doctest directive to place on the cmdline call, e.g. # doctest: +ELLIPSIS
