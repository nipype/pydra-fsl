"""
eddy
====

Correct for artifacts induced by Eddy currents and subject motion.
"""

__all__ = ["Eddy"]

import os

import attrs

import pydra


@attrs.define(slots=False, kw_only=True)
class EddySpec(pydra.specs.ShellSpec):
    """Specifications for eddy."""

    # Parameters that specify input files.
    input_image: os.PathLike = attrs.field(
        metadata={
            "help_string": "input image as a 4D volume of all images acquired in the diffusion protocol",
            "mandatory": True,
            "argstr": "--imain",
        }
    )

    mask_image: os.PathLike = attrs.field(
        metadata={
            "help_string": "brain mask as a single volume image",
            "mandatory": True,
            "argstr": "--mask",
        }
    )

    acquisition_parameters_file: os.PathLike = attrs.field(
        metadata={
            "help_string": "acquisition parameters for the diffusion protocol",
            "mandatory": True,
            "argstr": "--acqp",
        }
    )

    index_file: os.PathLike = attrs.field(
        metadata={
            "help_string": "mapping from volume index to acquisition parameters",
            "mandatory": True,
            "argstr": "--index",
        }
    )

    bvec_file: os.PathLike = attrs.field(
        metadata={
            "help_string": "diffusion directions",
            "mandatory": True,
            "argstr": "--bvecs",
        }
    )

    bval_file: os.PathLike = attrs.field(
        metadata={
            "help_string": "diffusion weighting",
            "mandatory": True,
            "argstr": "--bvals",
        }
    )

    topup_file: os.PathLike = attrs.field(
        metadata={
            "help_string": "topup output file",
            "mandatory": True,
            "argstr": "--topup",
            "xor": {"fieldmap_image"},
        }
    )

    fieldmap_image: os.PathLike = attrs.field(
        metadata={
            "help_string": "fieldmap file",
            "mandatory": True,
            "argstr": "--field",
            "xor": {"topup_file"},
        }
    )

    fieldmap_matrix: os.PathLike = attrs.field(
        metadata={
            "help_string": "rigid-body transformation matrix from fieldmap to first input volume",
            "argstr": "--field_mat",
            "requires": {"fieldmap_image"},
        }
    )

    no_peas: bool = attrs.field(
        metadata={
            "help_string": "do not perform post-Eddy alignment of shells",
            "argstr": "--dont_peas",
        }
    )

    # Parameters specifying names of output-files.
    output_basename: str = attrs.field(
        default="eddy",
        metadata={
            "help_string": "basename for output files",
            "argstr": "--out",
        },
    )

    # Parameters specifying how eddy should be run.
    first_level_model: str = attrs.field(
        default="quadratic",
        metadata={
            "help_string": "model for the magnetic field generated by Eddy currents",
            "argstr": "--flm",
            "allowed_values": {"movement", "linear", "quadratic", "cubic"},
        },
    )

    second_level_model: str = attrs.field(
        default="none",
        metadata={
            "help_string": "model for how diffusion gradients generate Eddy currents",
            "argstr": "--slm",
            "allowed_values": {"none", "linear", "quadratic"},
        },
    )

    fwhm: float = attrs.field(
        default=0,
        metadata={
            "help_string": "filter width used for pre-conditioning data prior to estimating distortions",
            "argstr": "--fwhm",
        },
    )

    num_iterations: int = attrs.field(
        default=5,
        metadata={
            "help_string": "number of iterations for eddy",
            "argstr": "--niter",
        },
    )

    fill_empty_planes: bool = attrs.field(
        metadata={
            "help_string": "detect and fill empty planes",
            "argstr": "--fep",
        }
    )

    interpolation: str = attrs.field(
        default="spline",
        metadata={
            "help_string": "interpolation method for the estimation phase",
            "argstr": "--interp",
            "allowed_values": {"spline", "trilinear"},
        },
    )

    resampling: str = attrs.field(
        default="jac",
        metadata={
            "help_string": "final resampling strategy",
            "argstr": "--resamp",
            "allowed_values": {"jac", "lsr"},
        },
    )

    num_voxels: int = attrs.field(
        default=1000,
        metadata={
            "help_string": "number of voxels to use for GP hyperparameter estimation",
            "argstr": "--nvoxhp",
        },
    )

    fudge_factor: int = attrs.field(
        default=10,
        metadata={
            "help_string": "fudge factor for Q-space smoothing during estimation",
            "argstr": "--ff",
        },
    )

    # Parameters for outlier replacement (ol)
    replace_outliers: bool = attrs.field(metadata={"help_string": "replace outliers", "argstr": "--repol"})

    outlier_num_stdevs: int = attrs.field(
        metadata={
            "help_string": "number of times off the standard deviation to qualify as outlier",
            "argstr": "--ol_nstd",
            "requires": {"replace_outliers"},
        }
    )

    outlier_num_voxels: int = attrs.field(
        metadata={
            "help_string": "minimum number of voxels in a slice to qualify for outlier detection",
            "argstr": "--ol_nvox",
            "requires": {"replace_outliers"},
        }
    )

    outlier_type: str = attrs.field(
        metadata={
            "help_string": "type of outliers detected",
            "argstr": "--ol_type",
            "allowed_values": {"both", "gw", "sw"},
            "requires": {"replace_outliers"},
        }
    )

    multiband_factor: int = attrs.field(
        metadata={
            "help_string": "multiband factor",
            "argstr": "--mb",
        }
    )

    multiband_offset: int = attrs.field(
        metadata={
            "help_string": "multiband slice offset",
            "argstr": "--mb_offs",
            "requires": {"multiband_factor"},
        }
    )

    # Parameters for intra-volume movement correction (s2v)
    movement_prediction_order: int = attrs.field(
        default=0,
        metadata={
            "help_string": "order of movement prediction model",
            "argstr": "--mporder",
        },
    )

    s2v_num_iterations: int = attrs.field(
        metadata={
            "help_string": "number of iterations for s2v movement estimation",
            "argstr": "--s2v_niter",
        }
    )

    s2v_lambda: float = attrs.field(
        metadata={
            "help_string": "weighting of regularization for s2v movement estimation",
            "argstr": "--s2v_lambda",
        }
    )

    s2v_interpolation: str = attrs.field(
        metadata={
            "help_string": "interpolation method for s2v movement estimation.",
            "argstr": "--s2v_interp",
            "allowed_values": {"spline", "trilinear"},
        }
    )

    slice_grouping_file: os.PathLike = attrs.field(
        metadata={
            "help_string": "file containing slice grouping information",
            "argstr": "--slspec",
            "xor": {"slice_timing_file"},
        }
    )

    slice_timing_file: os.PathLike = attrs.field(
        metadata={
            "help_string": "file containing slice timing information",
            "argstr": "--json",
            "xor": {"slice_grouping_file"},
        }
    )

    # Parameters for move-by-susceptibility correction (mbs)
    estimate_move_by_susceptibility: bool = attrs.field(
        metadata={
            "help_string": "estimate susceptibility-induced field changes due to subject motion",
            "argstr": "--estimate_move_by_susceptibility",
        }
    )

    mbs_num_iterations: int = attrs.field(
        metadata={
            "help_string": "number of iterations for MBS field estimation",
            "argstr": "--mbs_niter",
            "requires": {"estimate_move_by_susceptibility"},
        }
    )

    mbs_lambda: int = attrs.field(
        metadata={
            "help_string": "weighting of regularization for MBS field estimation",
            "argstr": "--mbs_lambda",
            "requires": {"estimate_move_by_susceptibility"},
        }
    )

    mbs_knot_spacing: int = attrs.field(
        metadata={
            "help_string": "knot-spacing for MBS field estimation",
            "argstr": "--mbs_ksp",
            "requires": {"estimate_move_by_susceptibility"},
        }
    )

    # Miscellaneous parameters.
    data_is_shelled: bool = attrs.field(
        metadata={
            "help_string": "bypass checks for data shelling",
            "argstr": "--data_is_shelled",
        }
    )

    random_seed: int = attrs.field(
        metadata={
            "help_string": "random seed for voxel selection",
            "argstr": "--initrand",
        }
    )

    save_cnr_maps: bool = attrs.field(
        metadata={
            "help_string": "save shell-wise CNR maps",
            "argstr": "--cnr_maps",
        }
    )

    save_residuals: bool = attrs.field(
        metadata={
            "help_string": "save residuals for all scans",
            "argstr": "--residuals",
        }
    )

    verbose: bool = attrs.field(
        metadata={
            "help_string": "enable verbose logging",
            "argstr": "-v",
        }
    )


class EddyOutSpec(pydra.specs.ShellOutSpec):
    """Output specification for eddy."""

    corrected_image: pydra.specs.File = attrs.field(
        metadata={
            "help_string": "input image corrected for distortions",
            "output_file_template": "{output_basename}.nii.gz",
        }
    )

    parameters_file: pydra.specs.File = attrs.field(
        metadata={
            "help_string": "registration parameters for movement and EC",
            "output_file_template": "{output_basename}.eddy_parameters",
        }
    )

    rotated_bvec_file: pydra.specs.File = attrs.field(
        metadata={
            "help_string": "rotated b-vecs",
            "output_file_template": "{output_basename}.eddy_rotated_bvecs",
        }
    )

    movement_rms_matrix: pydra.specs.File = attrs.field(
        metadata={
            "help_string": "movement induced RMS",
            "output_file_template": "{output_basename}.eddy_movement_rms",
        }
    )

    restricted_movement_rms_matrix: pydra.specs.File = attrs.field(
        metadata={
            "help_string": "movement induced RMS without translation in the PE direction",
            "output_file_template": "{output_basename}.eddy_restricted_movement_rms",
        }
    )

    displacement_fields_image: pydra.specs.File = attrs.field(
        metadata={
            "help_string": "displacement fields in millimeters",
            "output_file_template": "{output_basename}.eddy_displacement_fields",
        }
    )

    outlier_free_image: pydra.specs.File = attrs.field(
        metadata={
            "help_string": "input image with outliers replaced by predictions",
            "output_file_template": "{output_basename}.eddy_outlier_free_data",
            "requires": ["replace_outliers"],
        }
    )

    movement_over_time_file: pydra.specs.File = attrs.field(
        metadata={
            "help_string": "movement parameters per time-point (slice or group)",
            "output_file_template": "{output_basename}.eddy_movement_over_time",
            "requires": ["movement_prediction_order"],
        }
    )

    cnr_maps_image: pydra.specs.File = attrs.field(
        metadata={
            "help_string": "path to optional CNR maps image",
            "output_file_template": "{output_basename}.eddy_cnr_maps",
            "requires": ["save_cnr_maps"],
        }
    )

    residuals_image: pydra.specs.File = attrs.field(
        metadata={
            "help_string": "path to optional residuals image",
            "output_file_template": "{output_basename}.eddy_residuals",
            "requires": ["save_residuals"],
        }
    )


class Eddy(pydra.engine.ShellCommandTask):
    """Task definition for eddy."""

    executable = "eddy"

    input_spec = pydra.specs.SpecInfo(name="EddyInput", bases=(EddySpec,))

    output_spec = pydra.specs.SpecInfo(name="EddyOutput", bases=(EddyOutSpec,))
