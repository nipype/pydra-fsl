from pydra.engine import specs
from pydra import ShellCommandTask
import typing as ty

input_fields = [
    (
        "ref_file",
        specs.File,
        {
            "help_string": "name of reference image",
            "argstr": "--ref={ref_file}",
            "mandatory": True,
        },
    ),
    (
        "in_file",
        specs.File,
        {
            "help_string": "name of input image",
            "argstr": "--in={in_file}",
            "mandatory": True,
        },
    ),
    (
        "affine_file",
        specs.File,
        {
            "help_string": "name of file containing affine transform",
            "argstr": "--aff={affine_file}",
        },
    ),
    (
        "inwarp_file",
        specs.File,
        {
            "help_string": "name of file containing initial non-linear warps",
            "argstr": "--inwarp={inwarp_file}",
        },
    ),
    (
        "in_intensitymap_file",
        specs.MultiInputFile,
        {
            "help_string": "name of file/files containing initial intensity mapping usually generated by previous fnirt run",
            "argstr": "--intin={in_intensitymap_file}",
            "copyfile": False,
        },
    ),
    (
        "fieldcoeff_file",
        ty.Any,
        {
            "help_string": "name of output file with field coefficients or true",
            "argstr": "--cout={fieldcoeff_file}",
        },
    ),
    (
        "warped_file",
        str,
        {
            "help_string": "name of output image",
            "argstr": "--iout={warped_file}",
            "output_file_template": "{in_file}_warped",
        },
    ),
    (
        "field_file",
        ty.Any,
        {
            "help_string": "name of output file with field or true",
            "argstr": "--fout={field_file}",
        },
    ),
    (
        "jacobian_file",
        ty.Any,
        {
            "help_string": "name of file for writing out the Jacobian of the field (for diagnostic or VBM purposes)",
            "argstr": "--jout={jacobian_file}",
        },
    ),
    (
        "modulatedref_file",
        ty.Any,
        {
            "help_string": "name of file for writing out intensity modulated --ref (for diagnostic purposes)",
            "argstr": "--refout={modulatedref_file}",
        },
    ),
    (
        "out_intensitymap_file",
        ty.Any,
        {
            "help_string": "name of files for writing information pertaining to intensity mapping",
            "argstr": "--intout={out_intensitymap_file}",
        },
    ),
    (
        "log_file",
        str,
        {
            "help_string": "Name of log-file",
            "argstr": "--logout={log_file}",
            "output_file_template": "{in_file}_log.txt",
        },
    ),
    (
        "config_file",
        ty.Any,
        {
            "help_string": "Name of config file specifying command line arguments",
            "argstr": "--config={config_file}",
        },
    ),
    (
        "refmask_file",
        specs.File,
        {
            "help_string": "name of file with mask in reference space",
            "argstr": "--refmask={refmask_file}",
        },
    ),
    (
        "inmask_file",
        specs.File,
        {
            "help_string": "name of file with mask in input image space",
            "argstr": "--inmask={inmask_file}",
        },
    ),
    (
        "skip_refmask",
        bool,
        {
            "help_string": "Skip specified refmask if set, default false",
            "argstr": "--applyrefmask=0",
            "xor": ["apply_refmask"],
        },
    ),
    (
        "skip_inmask",
        bool,
        {
            "help_string": "skip specified inmask if set, default false",
            "argstr": "--applyinmask=0",
            "xor": ["apply_inmask"],
        },
    ),
    (
        "apply_refmask",
        list,
        {
            "help_string": "list of iterations to use reference mask on (1 to use, 0 to skip)",
            "argstr": "--applyrefmask={apply_refmask}",
            "sep": ",",
            "xor": ["skip_refmask"],
        },
    ),
    (
        "apply_inmask",
        list,
        {
            "help_string": "list of iterations to use input mask on (1 to use, 0 to skip)",
            "argstr": "--applyinmask={apply_inmask}",
            "sep": ",",
            "xor": ["skip_inmask"],
        },
    ),
    (
        "skip_implicit_ref_masking",
        bool,
        {
            "help_string": "skip implicit masking  based on value in --ref image. Default = 0",
            "argstr": "--imprefm=0",
        },
    ),
    (
        "skip_implicit_in_masking",
        bool,
        {
            "help_string": "skip implicit masking  based on value in --in image. Default = 0",
            "argstr": "--impinm=0",
        },
    ),
    (
        "refmask_val",
        float,
        {
            "help_string": "Value to mask out in --ref image. Default =0.0",
            "argstr": "--imprefval={refmask_val}",
        },
    ),
    (
        "inmask_val",
        float,
        {
            "help_string": "Value to mask out in --in image. Default =0.0",
            "argstr": "--impinval={inmask_val}",
        },
    ),
    (
        "max_nonlin_iter",
        list,
        {
            "help_string": "Max # of non-linear iterations list, default [5, 5, 5, 5]",
            "argstr": "--miter={max_nonlin_iter}",
            "sep": ",",
        },
    ),
    (
        "subsampling_scheme",
        list,
        {
            "help_string": "sub-sampling scheme, list, default [4, 2, 1, 1]",
            "argstr": "--subsamp={subsampling_scheme}",
            "sep": ",",
        },
    ),
    (
        "warp_resolution",
        ty.Any,
        {
            "help_string": "(approximate) resolution (in mm) of warp basis in x-, y- and z-direction, default 10, 10, 10",
            "argstr": "--warpres={warp_resolution},{warp_resolution},{warp_resolution}",
        },
    ),
    (
        "spline_order",
        int,
        {
            "help_string": "Order of spline, 2->Qadratic spline, 3->Cubic spline. Default=3",
            "argstr": "--splineorder={spline_order}",
        },
    ),
    (
        "in_fwhm",
        list,
        {
            "help_string": "FWHM (in mm) of gaussian smoothing kernel for input volume, default [6, 4, 2, 2]",
            "argstr": "--infwhm={in_fwhm}",
            "sep": ",",
        },
    ),
    (
        "ref_fwhm",
        list,
        {
            "help_string": "FWHM (in mm) of gaussian smoothing kernel for ref volume, default [4, 2, 0, 0]",
            "argstr": "--reffwhm={ref_fwhm}",
            "sep": ",",
        },
    ),
    (
        "regularization_model",
        ty.Any,
        {
            "help_string": "Model for regularisation of warp-field [membrane_energy bending_energy], default bending_energy",
            "argstr": "--regmod={regularization_model}",
        },
    ),
    (
        "regularization_lambda",
        list,
        {
            "help_string": "Weight of regularisation, default depending on --ssqlambda and --regmod switches. See user documetation.",
            "argstr": "--lambda={regularization_lambda}",
            "sep": ",",
        },
    ),
    (
        "skip_lambda_ssq",
        bool,
        {
            "help_string": "If true, lambda is not weighted by current ssq, default false",
            "argstr": "--ssqlambda=0",
        },
    ),
    (
        "jacobian_range",
        ty.Any,
        {
            "help_string": "Allowed range of Jacobian determinants, default 0.01, 100.0",
            "argstr": "--jacrange={jacobian_range},{jacobian_range}",
        },
    ),
    (
        "derive_from_ref",
        bool,
        {
            "help_string": "If true, ref image is used to calculate derivatives. Default false",
            "argstr": "--refderiv",
        },
    ),
    (
        "intensity_mapping_model",
        ty.Any,
        {
            "help_string": "Model for intensity-mapping",
            "argstr": "--intmod={intensity_mapping_model}",
        },
    ),
    (
        "intensity_mapping_order",
        int,
        {
            "help_string": "Order of poynomial for mapping intensities, default 5",
            "argstr": "--intorder={intensity_mapping_order}",
        },
    ),
    (
        "biasfield_resolution",
        ty.Any,
        {
            "help_string": "Resolution (in mm) of bias-field modelling local intensities, default 50, 50, 50",
            "argstr": "--biasres={biasfield_resolution},{biasfield_resolution},{biasfield_resolution}",
        },
    ),
    (
        "bias_regularization_lambda",
        float,
        {
            "help_string": "Weight of regularisation for bias-field, default 10000",
            "argstr": "--biaslambda={bias_regularization_lambda}",
        },
    ),
    (
        "skip_intensity_mapping",
        bool,
        {
            "help_string": "Skip estimate intensity-mapping default false",
            "argstr": "--estint=0",
            "xor": ["apply_intensity_mapping"],
        },
    ),
    (
        "apply_intensity_mapping",
        list,
        {
            "help_string": "List of subsampling levels to apply intensity mapping for (0 to skip, 1 to apply)",
            "argstr": "--estint={apply_intensity_mapping}",
            "sep": ",",
            "xor": ["skip_intensity_mapping"],
        },
    ),
    (
        "hessian_precision",
        ty.Any,
        {
            "help_string": "Precision for representing Hessian, double or float. Default double",
            "argstr": "--numprec={hessian_precision}",
        },
    ),
]
FNIRT_input_spec = specs.SpecInfo(name="Input", fields=input_fields, bases=(specs.ShellSpec,))

output_fields = [
    (
        "fieldcoeff_file",
        specs.File,
        {
            "help_string": "file with field coefficients",
            "requires": ["in_file"],
            "output_file_template": "{in_file}_fieldwarp",
        },
    ),
    (
        "field_file",
        specs.File,
        {
            "help_string": "file with warp field",
            "requires": ["in_file"],
            "output_file_template": "{in_file}_field",
        },
    ),
    (
        "jacobian_file",
        specs.File,
        {
            "help_string": "file containing Jacobian of the field",
            "requires": ["in_file"],
            "output_file_template": "{in_file}_field_jacobian",
        },
    ),
    (
        "modulatedref_file",
        specs.File,
        {
            "help_string": "file containing intensity modulated --ref",
            "requires": ["in_file"],
            "output_file_template": "{in_file}_modulated",
        },
    ),
]
FNIRT_output_spec = specs.SpecInfo(
    name="Output", fields=output_fields, bases=(specs.ShellOutSpec,)
)


class FNIRT(ShellCommandTask):
    input_spec = FNIRT_input_spec
    output_spec = FNIRT_output_spec
    executable = "fnirt"
